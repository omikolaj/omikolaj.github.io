---
layout: post
title:      "Ruby on Rails - Quick and 'Easy'"
date:       2018-02-01 11:12:24 +0000
permalink:  ruby_on_rails_-_quick_and_easy
---

I remember reading about Ruby on Rails and how it is a fast and 'easy' way of creating web-based application. Going through the section, I remember thinking to myself, ok so when are we going to learn the easy part? Moving from Sinatra to Rails seemed more complex with more moving parts and trying to understand and see the whole picture was a more difficult task to complete than before. To cement the principles, I re-read Rails sections, going over the same material several times helped me get the edge and understanding of how to tackle my project. Moving along in the process you never know where your next biggest challenge lies, continuously teaching you to think outside the box and keeping you on your toes to learn something new.

Even though you have a good idea of what you will be creating, what the relationships are going to look like, what kind of forms and routes you will use. You will come across challenges that you could not have foreseen. This was one of the biggest take always from this project. Expect the unexpected. Once the design process was complete I started mapping everything out with very basic design to make sure the routes, forms and models were working as expected.

Not long into the process the first road-block I ran into was creating the appropriate Active Record relationships. Considering three models, 'Dealership', 'Vehicle' and 'DealershipVehicle' where the ‘DealershipVehicle’ serves as the join table linking individual vehicle to a dealership, I was quick to conclude that the mapping will be easy. This is a typical two models one join table design, so I decided to follow the pattern where 'Dealership' `has_many vehicles,  :through => :dealership_vehicles`,  `has_many :dealership_vehicles` the 'Vehicle' model would then have `has_many :dealership_vehicles`, `has_many dealerships , :through => dealership_vehicles` and the last relationship would be just sewing the two  together as the join model where 'DealershipVehicle' would `belongs_to :vehicle` and `belongs_to :dealership`. Done and done right! NOPE! 

This perhaps isn't an issue, however I had a vision in mind and an idea that I wasn't willing to change simply because I didn’t know how else to implemented it. 

It was time to implement the firs C in Crud and forms have exposed it all! This whole time I knew that in my controllers and models I wanted to be able to say`@vehicle.dealership` and get back the dealership to which this vehicle instance belonged to. Since a vehicle can only belong to one dealership at a time, this made perfect sense. However, according to my models I did not have this available to me, I instead had `@vehicle.dealerships`. This wasn't going to allow me to mimic the real world of how dealerships operate. This wasn't as easy of a fix as I had hoped. I have read more Stack Overflow posts than ever before trying to get an idea of how to re-write my relationships. The problem was that I didn't know exactly how to phrase what I was looking for. I could tell I was getting closer as my searches went on, but it wasn't enough to guide me in the right direction. 

I needed to take a step backwards and really think about what I was trying to find out, that could not only apply to my situation, but something that someone else had ran into before. I had an 'aha!' moment! It took one or two searches and I found a post that had the same exact issue as I had run into and with an elegant solution too! This would allow me to assign a vehicle to a single dealership and have the join table store information that would be relevant to the join model. Perfect!

My new Active Record relationship needed to be forged, existing relationships needed to be modified to reflect that the vehicle can only have one dealership but it can only have one dealership through a join table, to allow me to store more information in the join model. This has exposed me to new Active Record relationships that I have not used before. The 'Dealership' model would essentially stay the same `has_many :dealership_vehicles` and `has_many :vehicles, :through => dealership_vehicles`. The 'Vehicle' model would now be modified to `belongs_to :dealership-vehicle` and `has_one :dealership, :through => :dealership_vehicle`. The `has_one, :through => :dealership_vehicle` relationship was what would allow me to associate a vehicle to only one ‘Dealership’ through the join table. Now the 'Vehicle’ table has a foreign key of `dealership_vehicle` which allows me to look up which 'Dealership' it belongs to. The 'DealershipVehicle' model was modified to reflect the fact that it can only belong to one 'Dealership' however it could have `has_many :vehicles`. Since a dealership could have multiple vehicles this all made sense. 

After the completion of this project, I feel very confident with Ruby on Rails which favors convention over configuration. Allowing developers to really create full web-based application quickly and 'easily'. The second part starts making sense once you fully understand the powers of Rails. From creating and configuring deeply nested forms, to omniauth using GitHub strategy, to implementing custom authentication and authorization, I look forward to working on many more projects that are built using Ruby on Rails and continuing to learn!

